
SECCIÓN 1:
*********

Repo del proyecto: https://github.com/vinsguru/spring-webflux-course

Necesidad de WebFlux:

En arquitecturas tradicionales, incluso en microservicios, se ve que se crean múltiples threads
para procesar las peticiones I/O. Sin embargo, estos threads quedan en un estado de "waiting" mientras
esperan la respuesta a los request que han sido enviados. Esto implica un uso de memoria ram muy alto
y recursos desperdiciados en ese "tiempo de espera del response" por una falta de "multitasking".

En el stack reactivo se introduce el término "non-blocking", quiere decir que los threads pueden procesar
una mayor cantidad de requests porque no esperan el response por cada petición. A diferencia de la 
arquitectura tradicional, los threads que están "libres" pueden seguir procesando requests y cuando 
llegue el response lo procesan en paralelo.


Reactive Manifesto -> Reactive Systems

Maintainable    Extensible

        Responsive
            |
  Elastic ----- Resilient
            |
        Message Driven

Responsive: Responder rápido y realizar el trabajo mientras el usuario lo requiera.
            Por ejemplo si el usuario ya cerró el browser el backend no debería seguir procesando.

Resilient: Permanecer responsive a pesar de los fallos. No tiene que caerse todo el sistema por una
           funcionalidad caída.

Elastic: El sistema escala automáticamente de acuerdo a la demanda.

Message Driven: Comunicación non-blocking & async entre sistemas. Se aplica el concepto de 
                Backpressure(si el sistema es lento para procesar los items recibidos se baja
                la carga de emisión).



SECCIÓN 3: Spring WebFlux
*************************

Spring Web corre en Servlet container(async y blocking)
Spring Web Reactive corre en Servlet 3.1, Netty, Undertow

Netty se basa en Thread Groups y tiene un "boss" y otros workers
que son los que procesan las operaciones I/O


webflux-demo

(Videos 16 y 17)
En la clase ReactiveMathController es clave el endpoint table/{input}/stream
porque demuestra dos ventajas de la programacion reactiva:

- Puede entregar el response apenas lo tenga
- Una vez cancelada la subscripción desde el navegador ya no se ejecuta ningún 
  proceso en el backend.

El endpoint que no tiene produces = MediaType.TEXT_EVENT_STREAM_VALUE toma un 
comportamiento por defecto que es realizar un collect de todos los elementos
y transformarlos a json para luego retornarlos. Esto se da por una lógica en
la clase AbstractJackson2Encoder.



SECCIÓN 4: Functional Endpoints
*******************************

Router Config: Para tener los endpoints de una manera funcional
Router Handler: El método que se ejecuta cuando el path funcional es invocado
Streaming Endpoint: tableStreamHandler para que el backend deje de procesar si se cancela la petición 
Functional Endpoints: GET, POST
Exception Handling: Método que maneja las excepciones
Path Based Routing Config: Es como el RequestMapping inicial en el mvc tradicional
Request Predicates: Complementa el RouterFunction con cierta lógica
Assignment: Se usó el manejo de headers


SECCIÓN 5: Webclient
********************

Es un Reactive RestTemplate para hacer peticiones HTTP

StepVerifier: Library Test
- GET Mono
- GET Flux
- GET Flux Streaming Endpoint (Stream emite cuando el item está listo)
- POST request
- String Request Header
- Handling Bad Request
- Exchange vs Retrieve --- exchange = retrieve + additional info(http status code)
- Query Params -- Se vieron tres maneras diferentes de hacerlo
- Setting Auth Token -- Se añadió código en WebClientConfig y en el test de Lec04HeadersTest
- Atrributes -- se usó para setear a different type of credentials at runtime.
  Para probar se debe activar sessionAttrToken en WebClientConfig.
- Assignment: Se usó doble flatmap para enviar valores


SECCIÓN 6: Spring Data Reactive - MongoDB
*****************************************

Se creó el product-service con las dependencias de maven:
- spring reactive web
- spring data reactive mongodb
- embedded mongodb database (testing) (comentar el scope test)
- lombok
Se agregó <version>${project.parent.version}</version> en el plugin para evitar el error:
"Plugin 'org.springframework.boot:spring-boot-maven-plugin:' not found"

- BeanUtils.copyProperties para transformar objetos con las propiedades
- Revisar doc sobre mappers & performance: 
  https://www.vinsguru.com/microservices-dto-to-entity-entity-to-dto-mapping-libraries-comparison/

- Se creó una instancia de docker con el comando: docker run -p 27017:27017 -d mongo

(De esta segunda forma sale error)
También se puede crear con el docker-compose.yml y el comando: docker-compose up

version: "3"
services:
  mongo:
    image: mongo
    ports:
      - 27017:27017
    volumes:
      - ./mongo:/data/db  
  mongo-express:
    image: mongo-express
    ports:
      - 8081:8081


Y para acceder al express server ir a localhost:8081


- Se comentó una dependencia de test en pom para que no se conecte a la bd en un ambiente de test.
Sin embargo, a mi eso nunca me funcionó y me conectaba a docker directamente.



SECCIÓN 7: Spring Data R2DBC
****************************

Documentación:
https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/#reference

Se creó el user-service con las dependencias de maven:
- spring reactive web
- spring data r2dbc
- h2
- lombok




















