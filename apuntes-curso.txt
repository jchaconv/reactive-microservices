
SECCIÓN 1:
*********

Necesidad de WebFlux:

En arquitecturas tradicionales, incluso en microservicios, se ve que se crean múltiples threads
para procesar las peticiones I/O. Sin embargo, estos threads quedan en un estado de "waiting" mientras
esperan la respuesta a los request que han sido enviados. Esto implica un uso de memoria ram muy alto
y recursos desperdiciados en ese "tiempo de espera del response" por una falta de "multitasking".

En el stack reactivo se introduce el término "non-blocking", quiere decir que los threads pueden procesar
una mayor cantidad de requests porque no esperan el response por cada petición. A diferencia de la 
arquitectura tradicional, los threads que están "libres" pueden seguir procesando requests y cuando 
llegue el response lo procesan en paralelo.


Reactive Manifesto -> Reactive Systems

Maintainable    Extensible

        Responsive
            |
  Elastic ----- Resilient
            |
        Message Driven

Responsive: Responder rápido y realizar el trabajo mientras el usuario lo requiera.
            Por ejemplo si el usuario ya cerró el browser el backend no debería seguir procesando.

Resilient: Permanecer responsive a pesar de los fallos. No tiene que caerse todo el sistema por una
           funcionalidad caída.

Elastic: El sistema escala automáticamente de acuerdo a la demanda.

Message Driven: Comunicación non-blocking & async entre sistemas. Se aplica el concepto de 
                Backpressure(si el sistema es lento para procesar los items recibidos se baja
                la carga de emisión).



SECCIÓN 3: Spring WebFlux
*************************

Spring Web corre en Servlet container(async y blocking)
Spring Web Reactive corre en Servlet 3.1, Netty, Undertow

Netty se basa en Thread Groups y tiene un "boss" y otros workers
que son los que procesan las operaciones I/O


webflux-demo

(Videos 16 y 17)
En la clase ReactiveMathController es clave el endpoint table/{input}/stream
porque demuestra dos ventajas de la programacion reactiva:

- Puede entregar el response apenas lo tenga
- Una vez cancelada la subscripción desde el navegador ya no se ejecuta ningún 
  proceso en el backend.

El endpoint que no tiene produces = MediaType.TEXT_EVENT_STREAM_VALUE toma un 
comportamiento por defecto que es realizar un collect de todos los elementos
y transformarlos a json para luego retornarlos. Esto se da por una lógica en
la clase AbstractJackson2Encoder.



SECCIÓN 4: Functional Endpoints
*******************************

Router Config: Para tener los endpoints de una manera funcional
Router Handler: El método que se ejecuta cuando el path funcional es invocado
Streaming Endpoint: tableStreamHandler para que el backend deje de procesar si se cancela la petición 
Functional Endpoints: GET, POST
Exception Handling: Método que maneja las excepciones
Path Based Routing Config: Es como el RequestMapping inicial en el mvc tradicional
Request Predicates: Complementa el RouterFunction con cierta lógica
Assignment: Se usó el manejo de headers






















